import fs from 'fs'
import path from 'path'
import type { Plugin } from './plugin'
import type { BuildOptions } from './build'
import { resolveBuildOptions } from './build'
import type { ResolvedServerOptions, ServerOptions } from './server'
import { resolveServerOptions } from './server'
import type { ResolvedPreviewOptions, PreviewOptions } from './preview'
import { resolvePreviewOptions } from './preview'
import type { CSSOptions } from './plugins/css'
import {
  arraify,
  createDebugger,
  isExternalUrl,
  isObject,
  lookupFile,
  normalizePath,
  dynamicImport
} from './utils'
import { resolvePlugins } from './plugins'
import colors from 'picocolors'
import type { ESBuildOptions } from './plugins/esbuild'
import dotenv from 'dotenv'
import dotenvExpand from 'dotenv-expand'
import type { Alias, AliasOptions } from 'types/alias'
import { CLIENT_ENTRY, ENV_ENTRY, DEFAULT_ASSETS_RE } from './constants'
import type { InternalResolveOptions, ResolveOptions } from './plugins/resolve'
import { resolvePlugin } from './plugins/resolve'
import type { Logger, LogLevel } from './logger'
import { createLogger } from './logger'
import type { DepOptimizationOptions } from './optimizer'
import { createFilter } from '@rollup/pluginutils'
import type { ResolvedBuildOptions } from '.'
import { parse as parseUrl } from 'url'
import type { JsonOptions } from './plugins/json'
import type { PluginContainer } from './server/pluginContainer'
import { createPluginContainer } from './server/pluginContainer'
import aliasPlugin from '@rollup/plugin-alias'
import { build } from 'esbuild'
import { performance } from 'perf_hooks'
import type { PackageCache } from './packages'
import type { RollupOptions } from 'rollup'

const debug = createDebugger('vite:config')

// NOTE: every export in this file is re-exported from ./index.ts so it will
// be part of the public API.
export interface ConfigEnv {
  command: 'build' | 'serve'
  mode: string
}

export type UserConfigFn = (env: ConfigEnv) => UserConfig | Promise<UserConfig>
export type UserConfigExport = UserConfig | Promise<UserConfig> | UserConfigFn

/**
 * Type helper to make it easier to use vite.config.ts
 * accepts a direct {@link UserConfig} object, or a function that returns it.
 * The function receives a {@link ConfigEnv} object that exposes two properties:
 * `command` (either `'build'` or `'serve'`), and `mode`.
 */
export function defineConfig(config: UserConfigExport): UserConfigExport {
  return config
}

export type PluginOption = Plugin | false | null | undefined

export interface UserConfig {
  /**
   * Project root directory. Can be an absolute path, or a path relative from
   * the location of the config file itself.
   * @default process.cwd()
   */
  /**
   * 项目根目录,可以使绝对路径,也可以是相对路径
   * 配置文件的位置
   * @default process.cwd() 默认位置
   */
  root?: string
  /**
   * Base public path when served in development or production.
   * @default '/'
   */
  /**
   * 在开发或者生产环境中基础的公共路径
   * @default '/'
   */
  base?: string
  /**
   * Directory to serve as plain static assets. Files in this directory are
   * served and copied to build dist dir as-is without transform. The value
   * can be either an absolute file system path or a path relative to <root>.
   *
   * Set to `false` or an empty string to disable copied static assets to build dist dir.
   * @default 'public'
   */
  /**
   * 作为静态资源的目录,这个目录下的文件会被原封不动的复制到构建的目录中
   * 这个值可以是绝对路径,也可以是相对于<root>的路径
   * 设置为false或者空字符串,可以禁止复制静态资源到构建目录中
   * @default 'public'
   */
  publicDir?: string | false
  /**
   * Directory to save cache files. Files in this directory are pre-bundled
   * deps or some other cache files that generated by vite, which can improve
   * the performance. You can use `--force` flag or manually delete the directory
   * to regenerate the cache files. The value can be either an absolute file
   * system path or a path relative to <root>.
   * Default to `.vite` when no `package.json` is detected.
   * @default 'node_modules/.vite'
   */
  /**
   * 保存缓存文件的目录,这个目录下的文件是预先打包的依赖或者其他由vite生成的缓存文件
   * 这个可以提高性能,你可以使用--force标志或者手动删除这个目录来重新生成缓存文件
   * 这个值可以是绝对路径,也可以是相对于<root>的路径
   * 当没有检测到package.json时,默认为.vite
   * @default 'node_modules/.vite'
   */
  cacheDir?: string
  /**
   * Explicitly set a mode to run in. This will override the default mode for
   * each command, and can be overridden by the command line --mode option.
   */
  /**
   * 显式设置运行模式,这将覆盖每个命令的默认模式,并且可以被命令行的--mode选项覆盖
   * @default 'development'
   */
  mode?: string
  /**
   * Define global variable replacements.
   * Entries will be defined on `window` during dev and replaced during build.
   */
  /**
   * 定义全局变量替换
   * 在开发环境中,这些变量会被定义在window上,在构建时会被替换
   */
  define?: Record<string, any>
  /**
   * Array of vite plugins to use.
   */
  /**
   * 使用的vite插件数组
   */
  plugins?: (PluginOption | PluginOption[])[]
  /**
   * Configure resolver
   */
  /**
   * 配置解析器
   */
  resolve?: ResolveOptions & { alias?: AliasOptions }
  /**
   * CSS related options (preprocessors and CSS modules)
   */
  /**
   * css相关的选项(预处理器和css模块)
   */
  css?: CSSOptions
  /**
   * JSON loading options
   */
  /**
   * json加载选项
   */
  json?: JsonOptions
  /**
   * Transform options to pass to esbuild.
   * Or set to `false` to disable esbuild.
   */
  /**
   * 传递给esbuild的转换选项
   */
  esbuild?: ESBuildOptions | false
  /**
   * Specify additional picomatch patterns to be treated as static assets.
   */
  /**
   * 指定额外的picomatch模式,被视为静态资源
   */
  assetsInclude?: string | RegExp | (string | RegExp)[]
  /**
   * Server specific options, e.g. host, port, https...
   */
  /**
   * 服务器特定的选项,例如host,port,https...
   */
  server?: ServerOptions
  /**
   * Build specific options
   */
  /**
   * 构建特定的选项
   */
  build?: BuildOptions
  /**
   * Preview specific options, e.g. host, port, https...
   */
  /**
   * 预览特定的选项,例如host,port,https...
   */
  preview?: PreviewOptions
  /**
   * Dep optimization options
   */
  /**
   * 依赖优化选项
   */
  optimizeDeps?: DepOptimizationOptions
  /**
   * SSR specific options
   * @alpha
   */
  /**
   * SSR特定的选项
   */
  ssr?: SSROptions
  /**
   * Log level.
   * Default: 'info'
   */
  /**
   * 日志级别
   */
  logLevel?: LogLevel
  /**
   * Custom logger.
   */
  /**
   * 自定义日志器
   */
  customLogger?: Logger
  /**
   * Default: true
   */
  /**
   * 默认为true
   */
  clearScreen?: boolean
  /**
   * Environment files directory. Can be an absolute path, or a path relative from
   * the location of the config file itself.
   * @default root
   */
  /**
   * 环境文件目录,可以是绝对路径,也可以是相对于配置文件本身的路径
   */
  envDir?: string
  /**
   * Env variables starts with `envPrefix` will be exposed to your client source code via import.meta.env.
   * @default 'VITE_'
   */
  /**
   * 以envPrefix开头的环境变量将通过import.meta.env暴露给客户端源代码
   */
  envPrefix?: string | string[]
  /**
   * Import aliases
   * @deprecated use `resolve.alias` instead
   */
  /**
   * 导入别名
   * @deprecated 使用`resolve.alias`代替
   */
  alias?: AliasOptions
  /**
   * Force Vite to always resolve listed dependencies to the same copy (from
   * project root).
   * @deprecated use `resolve.dedupe` instead
   */
  /**
   * 强制Vite始终将列出的依赖项解析为同一副本(从项目根目录)
   * @deprecated 使用`resolve.dedupe`代替
   */
  dedupe?: string[]
  /**
   * Worker bundle options
   */
  /**
   * worker包选项
   */
  worker?: {
    /**
     * Output format for worker bundle
     * @default 'iife'
     */
    format?: 'es' | 'iife'
    /**
     * Vite plugins that apply to worker bundle
     */
    plugins?: (PluginOption | PluginOption[])[]
    /**
     * Rollup options to build worker bundle
     */
    rollupOptions?: Omit<
      RollupOptions,
      'plugins' | 'input' | 'onwarn' | 'preserveEntrySignatures'
    >
  }
}

export type SSRTarget = 'node' | 'webworker'

export interface SSROptions {
  external?: string[]
  noExternal?: string | RegExp | (string | RegExp)[] | true
  /**
   * Define the target for the ssr build. The browser field in package.json
   * is ignored for node but used if webworker is the target
   * Default: 'node'
   */
  target?: SSRTarget
}

export interface ResolveWorkerOptions {
  format: 'es' | 'iife'
  plugins: Plugin[]
  rollupOptions: RollupOptions
}

export interface InlineConfig extends UserConfig {
  configFile?: string | false
  envFile?: false
}

export type ResolvedConfig = Readonly<
  Omit<
    UserConfig,
    'plugins' | 'alias' | 'dedupe' | 'assetsInclude' | 'optimizeDeps' | 'worker'
  > & {
    configFile: string | undefined
    configFileDependencies: string[]
    inlineConfig: InlineConfig
    root: string
    base: string
    publicDir: string
    cacheDir: string
    command: 'build' | 'serve'
    mode: string
    isWorker: boolean
    isProduction: boolean
    env: Record<string, any>
    resolve: ResolveOptions & {
      alias: Alias[]
    }
    plugins: readonly Plugin[]
    server: ResolvedServerOptions
    build: ResolvedBuildOptions
    preview: ResolvedPreviewOptions
    assetsInclude: (file: string) => boolean
    logger: Logger
    createResolver: (options?: Partial<InternalResolveOptions>) => ResolveFn
    optimizeDeps: Omit<DepOptimizationOptions, 'keepNames'>
    /** @internal */
    packageCache: PackageCache
    worker: ResolveWorkerOptions
  }
>

export type ResolveFn = (
  id: string,
  importer?: string,
  aliasOnly?: boolean,
  ssr?: boolean
) => Promise<string | undefined>

/**
 * 处理配置信息
 * @param inlineConfig 命令行接受的参数
 * @param command 运行模式 build | serve
 * @param defaultMode 运行环境 development | production
 */
export async function resolveConfig(
  inlineConfig: InlineConfig,
  command: 'build' | 'serve',
  defaultMode = 'development'
): Promise<ResolvedConfig> {
  let config = inlineConfig
  let configFileDependencies: string[] = []
  //如果命令行没有传入这个参数就使用默认的配置的模式(这个默认模式上个函数createServer传入的)
  let mode = inlineConfig.mode || defaultMode

  //设置process.env.NODE_ENV的值
  if (mode === 'production') {
    process.env.NODE_ENV = 'production'
  }

  const configEnv = {
    mode,
    command
  }
  //配置文件目录
  let { configFile } = config
  //如果命令行没有传入配置文件目录就使用默认的配置文件目录
  if (configFile !== false) {
    const loadResult = await loadConfigFromFile(
      configEnv,
      configFile,
      config.root,
      config.logLevel
    )
    if (loadResult) {
      //读取的配置和命令行传入的配置合并
      config = mergeConfig(loadResult.config, config)
      configFile = loadResult.path
      configFileDependencies = loadResult.dependencies
    }
  }

  // Define logger
  const logger = createLogger(config.logLevel, {
    allowClearScreen: config.clearScreen,
    customLogger: config.customLogger
  })

  // user config may provide an alternative mode. But --mode has a higher priority
  //命令行传入配置更高一级
  mode = inlineConfig.mode || config.mode || mode
  configEnv.mode = mode

  // 处理插件
  //flat 拍平数组,默认深度为1
  //读取插件
  const rawUserPlugins = (config.plugins || []).flat().filter((p) => {
    if (!p) {
      return false
    } else if (!p.apply) {
      return true
    } else if (typeof p.apply === 'function') {
      return p.apply({ ...config, mode }, configEnv)
    } else {
      return p.apply === command
    }
  }) as Plugin[]
  //读取插件的配置,以及分类插件
  const [prePlugins, normalPlugins, postPlugins] =
    sortUserPlugins(rawUserPlugins)

  // 处理worker参数
  const resolvedWorkerOptions: ResolveWorkerOptions = {
    format: config.worker?.format || 'iife',
    plugins: [],
    rollupOptions: config.worker?.rollupOptions || {}
  }

  // run config hooks
  const userPlugins = [...prePlugins, ...normalPlugins, ...postPlugins]
  for (const p of userPlugins) {
    if (p.config) {
      const res = await p.config(config, configEnv)
      if (res) {
        config = mergeConfig(config, res)
      }
    }
  }

  // 处理根目录
  const resolvedRoot = normalizePath(
    config.root ? path.resolve(config.root) : process.cwd()
  )

  //内置别名配置
  const clientAlias = [
    { find: /^[\/]?@vite\/env/, replacement: () => ENV_ENTRY },
    { find: /^[\/]?@vite\/client/, replacement: () => CLIENT_ENTRY }
  ]

  // resolve alias with internal client alias
  // 处理别名,处理成标准格式[{"find":"@","replacement":"/Users/xxx/xxx/xxx"}]
  //可能resolve.alias ||alias 是一个对象,也可能是一个数组
  const resolvedAlias = normalizeAlias(
    mergeAlias(
      // @ts-ignore because @rollup/plugin-alias' type doesn't allow function
      // replacement, but its implementation does work with function values.
      clientAlias,
      config.resolve?.alias || config.alias || []
    )
  )
  //resolve 配置信息
  const resolveOptions: ResolvedConfig['resolve'] = {
    dedupe: config.dedupe,
    ...config.resolve,
    alias: resolvedAlias
  }

  // load .env.development files
  //获取项目路径
  const envDir = config.envDir
    ? normalizePath(path.resolve(resolvedRoot, config.envDir))
    : resolvedRoot

  //获取.env.[mode]文件中环境变量
  const userEnv =
    inlineConfig.envFile !== false &&
    loadEnv(mode, envDir, resolveEnvPrefix(config))

  // Note it is possible for user to have a custom mode, e.g. `staging` where
  // production-like behavior is expected. This is indicated by NODE_ENV=production
  // loaded from `.staging.env` and set by us as VITE_USER_NODE_ENV
  //判断是否是生产环境设置NODE环境变量
  const isProduction = (process.env.VITE_USER_NODE_ENV || mode) === 'production'
  if (isProduction) {
    // in case default mode was not production and is overwritten
    process.env.NODE_ENV = 'production'
  }

  // resolve public base url
  //处理公共路径
  const BASE_URL = resolveBaseUrl(config.base, command === 'build', logger)
  const resolvedBuildOptions = resolveBuildOptions(config.build)

  // resolve cache directory
  //package.json中路径
  const pkgPath = lookupFile(resolvedRoot, [`package.json`], { pathOnly: true })
  //缓存文件目录获取,默认是node_modules/.vite,但是用户可以传入配置自定义位置
  const cacheDir = config.cacheDir
    ? path.resolve(resolvedRoot, config.cacheDir)
    : pkgPath
    ? path.join(path.dirname(pkgPath), `node_modules/.vite`)
    : path.join(resolvedRoot, `.vite`)
  //TODO 这个参数用处是什么?
  const assetsFilter = config.assetsInclude
    ? createFilter(config.assetsInclude)
    : () => false

  // create an internal resolver to be used in special scenarios, e.g.
  // optimizer & handling css @imports
  //TODO
  //创建一个内部的解析器,用于特殊的场景,比如优化器和处理css @imports
  const createResolver: ResolvedConfig['createResolver'] = (options) => {
    let aliasContainer: PluginContainer | undefined
    let resolverContainer: PluginContainer | undefined
    return async (id, importer, aliasOnly, ssr) => {
      let container: PluginContainer
      if (aliasOnly) {
        container =
          aliasContainer ||
          (aliasContainer = await createPluginContainer({
            ...resolved,
            plugins: [aliasPlugin({ entries: resolved.resolve.alias })]
          }))
      } else {
        container =
          resolverContainer ||
          (resolverContainer = await createPluginContainer({
            ...resolved,
            plugins: [
              aliasPlugin({ entries: resolved.resolve.alias }),
              resolvePlugin({
                ...resolved.resolve,
                root: resolvedRoot,
                isProduction,
                isBuild: command === 'build',
                ssrConfig: resolved.ssr,
                asSrc: true,
                preferRelative: false,
                tryIndex: true,
                ...options
              })
            ]
          }))
      }
      return (await container.resolveId(id, importer, { ssr }))?.id
    }
  }
  //静态资源目录
  const { publicDir } = config
  //处理静态资源目录为标准格式 eg:/Users/wzj/Desktop/wzj/vite/source-code/vite/demo/my-vue-app/public
  const resolvedPublicDir =
    publicDir !== false && publicDir !== ''
      ? path.resolve(
          resolvedRoot,
          typeof publicDir === 'string' ? publicDir : 'public'
        )
      : ''
  // 处理运行时配置参数 eg:设置启动端口号
  const server = resolveServerOptions(resolvedRoot, config.server)

  const resolved: ResolvedConfig = {
    ...config,
    configFile: configFile ? normalizePath(configFile) : undefined,
    configFileDependencies: configFileDependencies.map((name) =>
      normalizePath(path.resolve(name))
    ),
    inlineConfig,
    root: resolvedRoot,
    base: BASE_URL,
    resolve: resolveOptions,
    publicDir: resolvedPublicDir,
    cacheDir,
    command,
    mode,
    isWorker: false,
    isProduction,
    plugins: userPlugins,
    server,
    build: resolvedBuildOptions,
    preview: resolvePreviewOptions(config.preview, server),
    env: {
      ...userEnv,
      BASE_URL,
      MODE: mode,
      DEV: !isProduction,
      PROD: isProduction
    },
    assetsInclude(file: string) {
      return DEFAULT_ASSETS_RE.test(file) || assetsFilter(file)
    },
    logger,
    packageCache: new Map(),
    createResolver,
    optimizeDeps: {
      ...config.optimizeDeps,
      esbuildOptions: {
        keepNames: config.optimizeDeps?.keepNames,
        preserveSymlinks: config.resolve?.preserveSymlinks,
        ...config.optimizeDeps?.esbuildOptions
      }
    },
    worker: resolvedWorkerOptions
  }

  // flat config.worker.plugin
  const [workerPrePlugins, workerNormalPlugins, workerPostPlugins] =
    sortUserPlugins(config.worker?.plugins as Plugin[])
  const workerResolved: ResolvedConfig = { ...resolved, isWorker: true }
  resolved.worker.plugins = await resolvePlugins(
    workerResolved,
    workerPrePlugins,
    workerNormalPlugins,
    workerPostPlugins
  )
  // call configResolved worker plugins hooks
  await Promise.all(
    resolved.worker.plugins.map((p) => p.configResolved?.(workerResolved))
  )
  ;(resolved.plugins as Plugin[]) = await resolvePlugins(
    resolved,
    prePlugins,
    normalPlugins,
    postPlugins
  )

  // call configResolved hooks
  await Promise.all(userPlugins.map((p) => p.configResolved?.(resolved)))

  if (process.env.DEBUG) {
    debug(`using resolved config: %O`, {
      ...resolved,
      plugins: resolved.plugins.map((p) => p.name)
    })
  }

  // TODO Deprecation warnings - remove when out of beta

  const logDeprecationWarning = (
    deprecatedOption: string,
    hint: string,
    error?: Error
  ) => {
    logger.warn(
      colors.yellow(
        colors.bold(
          `(!) "${deprecatedOption}" option is deprecated. ${hint}${
            error ? `\n${error.stack}` : ''
          }`
        )
      )
    )
  }

  if (config.build?.base) {
    logDeprecationWarning(
      'build.base',
      '"base" is now a root-level config option.'
    )
    config.base = config.build.base
  }
  Object.defineProperty(resolvedBuildOptions, 'base', {
    enumerable: false,
    get() {
      logDeprecationWarning(
        'build.base',
        '"base" is now a root-level config option.',
        new Error()
      )
      return resolved.base
    }
  })

  if (config.alias) {
    logDeprecationWarning('alias', 'Use "resolve.alias" instead.')
  }
  Object.defineProperty(resolved, 'alias', {
    enumerable: false,
    get() {
      logDeprecationWarning(
        'alias',
        'Use "resolve.alias" instead.',
        new Error()
      )
      return resolved.resolve.alias
    }
  })

  if (config.dedupe) {
    logDeprecationWarning('dedupe', 'Use "resolve.dedupe" instead.')
  }
  Object.defineProperty(resolved, 'dedupe', {
    enumerable: false,
    get() {
      logDeprecationWarning(
        'dedupe',
        'Use "resolve.dedupe" instead.',
        new Error()
      )
      return resolved.resolve.dedupe
    }
  })

  if (config.optimizeDeps?.keepNames) {
    logDeprecationWarning(
      'optimizeDeps.keepNames',
      'Use "optimizeDeps.esbuildOptions.keepNames" instead.'
    )
  }
  Object.defineProperty(resolved.optimizeDeps, 'keepNames', {
    enumerable: false,
    get() {
      logDeprecationWarning(
        'optimizeDeps.keepNames',
        'Use "optimizeDeps.esbuildOptions.keepNames" instead.',
        new Error()
      )
      return resolved.optimizeDeps.esbuildOptions?.keepNames
    }
  })

  if (config.build?.polyfillDynamicImport) {
    logDeprecationWarning(
      'build.polyfillDynamicImport',
      '"polyfillDynamicImport" has been removed. Please use @vitejs/plugin-legacy if your target browsers do not support dynamic imports.'
    )
  }

  Object.defineProperty(resolvedBuildOptions, 'polyfillDynamicImport', {
    enumerable: false,
    get() {
      logDeprecationWarning(
        'build.polyfillDynamicImport',
        '"polyfillDynamicImport" has been removed. Please use @vitejs/plugin-legacy if your target browsers do not support dynamic imports.',
        new Error()
      )
      return false
    }
  })

  if (config.build?.cleanCssOptions) {
    logDeprecationWarning(
      'build.cleanCssOptions',
      'Vite now uses esbuild for CSS minification.'
    )
  }

  if (config.build?.terserOptions && config.build.minify !== 'terser') {
    logger.warn(
      colors.yellow(
        `build.terserOptions is specified but build.minify is not set to use Terser. ` +
          `Note Vite now defaults to use esbuild for minification. If you still ` +
          `prefer Terser, set build.minify to "terser".`
      )
    )
  }

  return resolved
}

/**
 * Resolve base. Note that some users use Vite to build for non-web targets like
 * electron or expects to deploy
 */
/**
 * 解决base Url,解决一些用户使用Vite来构建非Web目标，如electron或预期部署的问题
 * @param base 路径
 * @param isBuild 是否是打包
 * @param logger
 */
function resolveBaseUrl(
  base: UserConfig['base'] = '/',
  isBuild: boolean,
  logger: Logger
): string {
  // #1669 special treatment for empty for same dir relative base
  if (base === '' || base === './') {
    return isBuild ? base : '/'
  }
  //startsWidth 判断是否以某个字符串开头
  if (base.startsWith('.')) {
    logger.warn(
      colors.yellow(
        colors.bold(
          `(!) invalid "base" option: ${base}. The value can only be an absolute ` +
            `URL, ./, or an empty string.`
        )
      )
    )
    base = '/'
  }

  // external URL
  if (isExternalUrl(base)) {
    if (!isBuild) {
      // get base from full url during dev
      const parsed = parseUrl(base)
      base = parsed.pathname || '/'
    }
  } else {
    // ensure leading slash
    if (!base.startsWith('/')) {
      logger.warn(
        colors.yellow(
          colors.bold(`(!) "base" option should start with a slash.`)
        )
      )
      base = '/' + base
    }
  }

  // ensure ending slash
  if (!base.endsWith('/')) {
    logger.warn(
      colors.yellow(colors.bold(`(!) "base" option should end with a slash.`))
    )
    base += '/'
  }

  return base
}
//TODO
function mergeConfigRecursively(
  defaults: Record<string, any>,
  overrides: Record<string, any>,
  rootPath: string
) {
  const merged: Record<string, any> = { ...defaults }
  for (const key in overrides) {
    const value = overrides[key]
    if (value == null) {
      continue
    }

    const existing = merged[key]

    if (existing == null) {
      merged[key] = value
      continue
    }

    // fields that require special handling
    if (key === 'alias' && (rootPath === 'resolve' || rootPath === '')) {
      merged[key] = mergeAlias(existing, value)
      continue
    } else if (key === 'assetsInclude' && rootPath === '') {
      merged[key] = [].concat(existing, value)
      continue
    } else if (key === 'noExternal' && existing === true) {
      continue
    }

    if (Array.isArray(existing) || Array.isArray(value)) {
      merged[key] = [...arraify(existing ?? []), ...arraify(value ?? [])]
      continue
    }
    if (isObject(existing) && isObject(value)) {
      merged[key] = mergeConfigRecursively(
        existing,
        value,
        rootPath ? `${rootPath}.${key}` : key
      )
      continue
    }

    merged[key] = value
  }
  return merged
}

/**
 * 合并配置
 * @param defaults
 * @param overrides
 * @param isRoot
 */
export function mergeConfig(
  defaults: Record<string, any>,
  overrides: Record<string, any>,
  isRoot = true
): Record<string, any> {
  return mergeConfigRecursively(defaults, overrides, isRoot ? '' : '.')
}

/**
 * 合并内置别名配置以及配置文件传入的配置
 * @param a 内置配置别名
 * @param b 配置文件别名
 */
function mergeAlias(
  a?: AliasOptions,
  b?: AliasOptions
): AliasOptions | undefined {
  if (!a) return b
  if (!b) return a
  //判断配置是否都是对象,如果都是对象形式可以直接合并返回,因为alias有多种写法
  if (isObject(a) && isObject(b)) {
    return { ...a, ...b }
  }
  // the order is flipped because the alias is resolved from top-down,
  // where the later should have higher priority
  return [...normalizeAlias(b), ...normalizeAlias(a)]
}
/**
 * 转换alias格式
 * 例如: {"A":"@/src"} 转换为 [{find:"A",replacement:"@/src"}] 以便后续处理
 * 简单的理解就是键值对转换为数组对象
 */
function normalizeAlias(o: AliasOptions = []): Alias[] {
  return Array.isArray(o)
    ? o.map(normalizeSingleAlias)
    : Object.keys(o).map((find) =>
        normalizeSingleAlias({
          find,
          replacement: (o as any)[find]
        })
      )
}

// https://github.com/vitejs/vite/issues/1363
// work around https://github.com/rollup/plugins/issues/759
/**
 * 组装alias{"find":"A","replacement":"@/src"}
 * @param find
 * @param replacement
 * @param customResolver
 */
function normalizeSingleAlias({
  find,
  replacement,
  customResolver
}: Alias): Alias {
  if (
    typeof find === 'string' &&
    find.endsWith('/') &&
    replacement.endsWith('/')
  ) {
    find = find.slice(0, find.length - 1)
    replacement = replacement.slice(0, replacement.length - 1)
  }

  const alias: Alias = {
    find,
    replacement
  }
  //传入就使用
  if (customResolver) {
    alias.customResolver = customResolver
  }
  return alias
}

/**
 * 插件分类根据`enforce`参数分为 前置插件 中置插件 后置插件
 * @param plugins
 */
export function sortUserPlugins(
  plugins: (Plugin | Plugin[])[] | undefined
): [Plugin[], Plugin[], Plugin[]] {
  const prePlugins: Plugin[] = []
  const postPlugins: Plugin[] = []
  const normalPlugins: Plugin[] = []

  if (plugins) {
    plugins.flat().forEach((p) => {
      if (p.enforce === 'pre') prePlugins.push(p)
      else if (p.enforce === 'post') postPlugins.push(p)
      else normalPlugins.push(p)
    })
  }

  return [prePlugins, normalPlugins, postPlugins]
}

/**
 * 从配置文件中加载配置
 * @param configEnv
 * @param configFile 配置文件目录
 * @param configRoot
 * @param logLevel
 */
export async function loadConfigFromFile(
  configEnv: ConfigEnv,
  configFile?: string,
  configRoot: string = process.cwd(),
  logLevel?: LogLevel
): Promise<{
  path: string
  config: UserConfig
  dependencies: string[]
} | null> {
  //性能计算埋点
  const start = performance.now()
  const getTime = () => `${(performance.now() - start).toFixed(2)}ms`

  let resolvedPath: string | undefined
  let isTS = false
  let isESM = false
  let dependencies: string[] = []

  //读取项目package.json判断项目模式是否采用esm模式
  try {
    const pkg = lookupFile(configRoot, ['package.json'])
    if (pkg && JSON.parse(pkg).type === 'module') {
      isESM = true
    }
  } catch (e) {}
  //这一段就一个目的,寻找配置文件
  if (configFile) {
    resolvedPath = path.resolve(configFile)
    //判断是否是ts文件
    isTS = configFile.endsWith('.ts')

    if (configFile.endsWith('.mjs')) {
      isESM = true
    }
  } else {
    //如果不存在配置文件路径，则根据项目模式采用默认的配置文件vite.config.js/vite.config.ts/vite.config.mjs/vite.config.cjs
    const jsconfigFile = path.resolve(configRoot, 'vite.config.js')
    if (fs.existsSync(jsconfigFile)) {
      resolvedPath = jsconfigFile
    }

    if (!resolvedPath) {
      const mjsconfigFile = path.resolve(configRoot, 'vite.config.mjs')
      if (fs.existsSync(mjsconfigFile)) {
        resolvedPath = mjsconfigFile
        isESM = true
      }
    }

    if (!resolvedPath) {
      const tsconfigFile = path.resolve(configRoot, 'vite.config.ts')
      if (fs.existsSync(tsconfigFile)) {
        resolvedPath = tsconfigFile
        isTS = true
      }
    }

    if (!resolvedPath) {
      const cjsConfigFile = path.resolve(configRoot, 'vite.config.cjs')
      if (fs.existsSync(cjsConfigFile)) {
        resolvedPath = cjsConfigFile
        isESM = false
      }
    }
  }

  if (!resolvedPath) {
    debug('no config file found.')
    return null
  }

  try {
    let userConfig: UserConfigExport | undefined

    if (isESM) {
      const fileUrl = require('url').pathToFileURL(resolvedPath)
      const bundled = await bundleConfigFile(resolvedPath, true)
      dependencies = bundled.dependencies
      if (isTS) {
        // before we can register loaders without requiring users to run node
        // with --experimental-loader themselves, we have to do a hack here:
        // bundle the config file w/ ts transforms first, write it to disk,
        // load it with native Node ESM, then delete the file.
        fs.writeFileSync(resolvedPath + '.js', bundled.code)
        //读取配置文件信息
        userConfig = (await dynamicImport(`${fileUrl}.js?t=${Date.now()}`))
          .default
        fs.unlinkSync(resolvedPath + '.js')
        debug(`TS + native esm config loaded in ${getTime()}`, fileUrl)
      } else {
        // using Function to avoid this from being compiled away by TS/Rollup
        // append a query so that we force reload fresh config in case of
        // server restart
        userConfig = (await dynamicImport(`${fileUrl}?t=${Date.now()}`)).default
        debug(`native esm config loaded in ${getTime()}`, fileUrl)
      }
    }

    if (!userConfig) {
      // Bundle config file and transpile it to cjs using esbuild.
      const bundled = await bundleConfigFile(resolvedPath)
      dependencies = bundled.dependencies
      userConfig = await loadConfigFromBundledFile(resolvedPath, bundled.code)
      debug(`bundled config file loaded in ${getTime()}`)
    }
    //判断配置文件是否是函数
    const config = await (typeof userConfig === 'function'
      ? userConfig(configEnv)
      : userConfig)
    if (!isObject(config)) {
      throw new Error(`config must export or return an object.`)
    }
    return {
      path: normalizePath(resolvedPath),
      config,
      dependencies
    }
  } catch (e) {
    createLogger(logLevel).error(
      colors.red(`failed to load config from ${resolvedPath}`),
      { error: e }
    )
    throw e
  }
}

/**
 * 利用esbuild读取配置文件信息
 * @param fileName
 * @param isESM
 */
async function bundleConfigFile(
  fileName: string,
  isESM = false
): Promise<{ code: string; dependencies: string[] }> {
  //esbuild
  const result = await build({
    absWorkingDir: process.cwd(),
    entryPoints: [fileName],
    outfile: 'out.js',
    write: false,
    platform: 'node',
    bundle: true,
    format: isESM ? 'esm' : 'cjs',
    sourcemap: 'inline',
    metafile: true,
    plugins: [
      {
        name: 'externalize-deps',
        setup(build) {
          build.onResolve({ filter: /.*/ }, (args) => {
            const id = args.path
            if (id[0] !== '.' && !path.isAbsolute(id)) {
              return {
                external: true
              }
            }
          })
        }
      },
      {
        name: 'replace-import-meta',
        setup(build) {
          build.onLoad({ filter: /\.[jt]s$/ }, async (args) => {
            const contents = await fs.promises.readFile(args.path, 'utf8')
            return {
              loader: args.path.endsWith('.ts') ? 'ts' : 'js',
              contents: contents
                .replace(
                  /\bimport\.meta\.url\b/g,
                  JSON.stringify(`file://${args.path}`)
                )
                .replace(
                  /\b__dirname\b/g,
                  JSON.stringify(path.dirname(args.path))
                )
                .replace(/\b__filename\b/g, JSON.stringify(args.path))
            }
          })
        }
      }
    ]
  })
  const { text } = result.outputFiles[0]
  return {
    code: text,
    dependencies: result.metafile ? Object.keys(result.metafile.inputs) : []
  }
}

interface NodeModuleWithCompile extends NodeModule {
  _compile(code: string, filename: string): any
}

async function loadConfigFromBundledFile(
  fileName: string,
  bundledCode: string
): Promise<UserConfig> {
  const extension = path.extname(fileName)
  const defaultLoader = require.extensions[extension]!
  require.extensions[extension] = (module: NodeModule, filename: string) => {
    if (filename === fileName) {
      ;(module as NodeModuleWithCompile)._compile(bundledCode, filename)
    } else {
      defaultLoader(module, filename)
    }
  }
  // clear cache in case of server restart
  delete require.cache[require.resolve(fileName)]
  const raw = require(fileName)
  const config = raw.__esModule ? raw.default : raw
  require.extensions[extension] = defaultLoader
  return config
}

/**
 * 加载环境变量文件中变量
 * @param mode 模式
 * @param envDir 项目路径
 * @param prefixes 环境变量前缀,可以在vite.config.ts中设置
 */
export function loadEnv(
  mode: string,
  envDir: string,
  prefixes: string | string[] = 'VITE_'
): Record<string, string> {
  //本地模式不加载
  if (mode === 'local') {
    throw new Error(
      `"local" cannot be used as a mode name because it conflicts with ` +
        `the .local postfix for .env files.`
    )
  }
  // 防止你传入对象正确格式["VITE_", "VUE_"] 兼容 {"VITE_", "VUE_"} 两种格式
  prefixes = arraify(prefixes)
  const env: Record<string, string> = {}
  //可能存在的文件格式
  const envFiles = [
    /** mode local file */ `.env.${mode}.local`,
    /** mode file */ `.env.${mode}`,
    /** local file */ `.env.local`,
    /** default file */ `.env`
  ]

  // check if there are actual env variables starting with VITE_*
  // these are typically provided inline and should be prioritized
  // 监测是否有以env中开头的实际环境变量
  // 这些通常是内联提供的，并且应该优先考虑
  for (const key in process.env) {
    if (
      prefixes.some((prefix) => key.startsWith(prefix)) &&
      env[key] === undefined
    ) {
      env[key] = process.env[key] as string
    }
  }

  for (const file of envFiles) {
    //寻找几种可能存在的文件格式路径是否存在
    const path = lookupFile(envDir, [file], { pathOnly: true, rootDir: envDir })
    if (path) {
      //dotenv 解析.env文件
      const parsed = dotenv.parse(fs.readFileSync(path), {
        debug: process.env.DEBUG?.includes('vite:dotenv') || undefined
      })

      // let environment variables use each other
      //让变量互相使用
      dotenvExpand({
        parsed,
        // prevent process.env mutation
        ignoreProcessEnv: true
      } as any)

      // only keys that start with prefix are exposed to client
      for (const [key, value] of Object.entries(parsed)) {
        if (
          prefixes.some((prefix) => key.startsWith(prefix)) &&
          env[key] === undefined
        ) {
          env[key] = value
        } else if (
          key === 'NODE_ENV' &&
          process.env.VITE_USER_NODE_ENV === undefined
        ) {
          // NODE_ENV override in .env.development file
          process.env.VITE_USER_NODE_ENV = value
        }
      }
    }
  }
  return env
}

//处理环境变量前缀为数组
export function resolveEnvPrefix({
  envPrefix = 'VITE_'
}: UserConfig): string[] {
  envPrefix = arraify(envPrefix)
  if (envPrefix.some((prefix) => prefix === '')) {
    throw new Error(
      `envPrefix option contains value '', which could lead unexpected exposure of sensitive information.`
    )
  }
  return envPrefix
}
